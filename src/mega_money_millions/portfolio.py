import pandas as pd

from mega_money_millions.exchange import truncate_decimal


class InsufficientFunds(Exception):
  def __init__(self, cash, ticker, price, quantity, cost, fee):
    super().__init__(
      f"Cannot purchase {quantity} shares of {ticker} @ {price}: cost {cost} (+ fee {fee}) > available cash {cash}")


class InsufficientShares(Exception):
  def __init__(self, total_quantity, ticker, price, quantity, fee):
    super().__init__(
      f"Cannot sell {quantity} shares of {ticker} @ {price} (- fee {fee}): only {total_quantity} shares owned")


class Portfolio:
  def __init__(self, exchange, initial_cash):
    self.initial_cash = initial_cash
    self.exchange = exchange
    # cost does NOT include fee
    self.positions = pd.DataFrame(columns=['time', 'ticker', 'price', 'quantity', 'cost', 'fee', 'cash'])

  def buy(self, ticker, date, price, quantity=None, percentage_of_cash=None):
    if quantity is None and percentage_of_cash is None or quantity is not None and percentage_of_cash is not None:
      raise ValueError("Must specify either quantity or percentage_of_cash")

    cash = self.cash()

    if percentage_of_cash is not None:
      quantity = self.exchange.max_quantity(ticker, price, truncate_decimal(cash * percentage_of_cash / 100.00, 4))

    cost = round(price * quantity, 4)
    fee = self.exchange.fee_for_buy(ticker, date, price, quantity)
    total_cost = cost + fee

    if total_cost > cash or total_cost <= 0:
      raise InsufficientFunds(cash, ticker, price, quantity, cost, fee)

    cash -= total_cost

    self.positions.loc[len(self.positions)] = [date, ticker, price, quantity, cost, fee, cash]

  def sell(self, ticker, date, price, quantity=None, percentage_of_shares=None):
    if quantity is None and percentage_of_shares is None or quantity is not None and percentage_of_shares is not None:
      raise ValueError("Must specify either quantity or percentage_of_shares")

    cash = self.cash()

    owned = self.quantity_owned(ticker)

    if quantity is None:
      quantity = truncate_decimal(owned * (float(percentage_of_shares) / 100), 4)

    fee = self.exchange.fee_for_sell(ticker, date, price, quantity)

    if owned < quantity:
      raise InsufficientShares(owned, ticker, price, quantity, fee)

    cost = round(price * quantity, 4)
    total_cost = cost - fee

    cash += total_cost

    self.positions.loc[len(self.positions)] = [date, ticker, price, -quantity, cost, fee, cash]

  def quantity_owned(self, ticker):
    return self.positions.loc[self.positions.ticker == ticker, 'quantity'].sum()

  def cash(self):
    if len(self.positions) > 0:
      return self.positions.iloc[-1]['cash']

    return self.initial_cash

  """
    Net Performance: Net Performance represents the overall performance of the strategy during the backtest period.
      It is measured as a percentage and indicates the net gain or loss generated by the strategy.
    Positions: Positions represents the total number of positions generated by the strategy during the backtest.
      Each position represents a trade or a set of trades with a specific entry and exit point.
    Wins: Wins represents the percentage of trades that resulted in a profit. A higher percentage indicates a higher win
      rate for the strategy.
    Win Streak, avg: Win Streak, avg. calculates the average number of consecutive winning trades. This metric helps
      assess the strategy’s ability to generate profitable trades consistently.
    Win Streak, max: Win Streak, max. represents the maximum number of consecutive winning trades. This metric provides
      insights into the strategy’s best winning streak.
    Losses: Losses represents the percentage of trades that resulted in a loss. A lower percentage indicates a higher
      percentage of profitable trades.
    Loss Streak, avg: Loss Streak, avg. calculates the average number of consecutive losing trades. It helps assess the
      strategy’s ability to withstand losing streaks.
    Loss Streak, max: Loss Streak, max. represents the maximum number of consecutive losing trades experienced by the
      strategy. This metric provides insights into the strategy’s worst losing streak.
    Max DD (Max Drawdown): Max Drawdown measures the largest percentage decline in the strategy’s overall equity from a
      peak to a subsequent trough. It indicates the maximum loss suffered by the strategy at any point during the
      backtest.
    Average Win: Average Win calculates the average return for winning trades. This metric provides insights into the
      average profitability of successful trades.
    Average Loss: Average Loss calculates the average return for losing trades. This metric helps assess the average
      magnitude of losses incurred by the strategy.
    Average Return: Average Return calculates the average return for all trades, whether they are winners or losers.
      This metric gives an overall picture of the average profitability of the strategy’s trades.
    Rew/Risk Ratio (Reward-to-Risk Ratio): The Reward-to-Risk Ratio is calculated by dividing the average win by the
      average loss. This ratio provides insights into the potential reward relative to the risk taken by the strategy.
    Avg. Length (Average Length): Average Length represents the average duration of a position, measured in candlestick
      periods. This metric helps assess the average holding period of trades generated by the strategy.
    Trades/Day: Trades/Day calculates the average number of trades executed per day during the backtest.
      This metric provides insights into the frequency of trading activity.
    Trades/Month: Trades/Month calculates the average number of trades executed per month during the backtest.
      This metric provides insights into the monthly trading activity of the strategy.
  """

  # https://trendspider.com/learning-center/basic-backtesting-metrics/
  def max_gain(self):
    pass

  def max_loss(self):
    pass

  def average_loss(self):
    pass

  def average_gain(self):
    pass

  def median_loss(self):
    pass

  def median_gain(self):
    pass
